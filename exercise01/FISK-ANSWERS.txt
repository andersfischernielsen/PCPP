
ANSWERS
==========

(?) = Indicates that I'm unsure of the answer.



Exercise 1.1
------------

* 1.1.1
We get result like "Count is 100534081 and should be 200000000" since running without syncronization makes the threads overwrite eachother's results, thereby having lost updates. 

* 1.1.2
With a smaller amount of operations (100) the chance of the threads interfering with each other is smaller.
I would not consider this software correct, since we can't guarantee anything in regards to order of execution when running concurrent code without syncronization.  
After running the example many times with counts=200, I finally got "Count is 384 and should be 400" illustrating that the same could happen with counts=100, even though the chance of this happening is even smaller, there's still a chance.  

* 1.1.3
No, changing the increment to either += or ++ would not change the erronous result, since these operations aren't atomic either, just like count = count + 1. 
Running with ++ we get smaller counts (no larger than 30 in our tests).
Running with += we get similar results as when running with count = count + 1. 

* 1.1.4
We don't know what the final value should be, since the code is not syncronized. 
The code suggests that the result would be 0, but since there's no syncronization, this cannot be guaranteed.
We will still lose updates and/or read stale data without syncronization. 
Tests show results anywhere between "Count is -8802343 and should be 0" and "Count is 9763543 and should be 0".

* 1.1.5
Running with only decrement being syncronized does not change the result from when running completely without syncronization.
Running with only increment being syncronized does not change the result from when running completely without syncronization.
Values for both of these are anywhere between "Count is 1824261 and should be 0" and "Count is -8469785 and should be 0".
Running with both increment and decrement syncronized gives the expected result 0. 
In the experiments where either increment or decrement isn't syncronized we still have reads og stale data or lost updates on either operation, resulting in the same results as running completely without syncronization. 
Race conditions therefore still occur.



Exercise 1.2
------------

* 1.2.1
Both threads can call the print method simultaneously, thereby printing symbols in the "wrong order".
In the scenario where one thread is sleeping and has just printed a dash or a line and the other thread then prints either of the two symbols, a double dash or line will occur. 

* 1.2.2 
Making the print method syncronous would prevent either thread from printing while the other thread is printing, therefore only 

* 1.2.3 
* 1.2.4
* 1.2.5
N/A



Exercise 1.3
------------

* 1.3.1
Yes, we observe the same behaviour. 

* 1.3.2
Yes, the thread terminates as expected now. 

* 1.3.3
No, it does not terminate as expected. 
The value will not be visible across threads. (?)
Furthermore, if the get method is not synchronized, then it's still possible to get() the value before it is initialized, and therefore the thread will loop forever. 


* 1.3.4
Making value volatile gives the desired behaviour. 
(?) Since the MutableInteger does not expose the inner value to other threads, and only modifies it internally through public methods, then we would argue that this is enough.



Exercise 1.4
------------

* 1.4.1
Sequential result:     664579
java TestCountPrimes  7.63s user 0.06s system 100% cpu 7.621 total

* 1.4.2
Parallel10 result:     664579
java TestCountPrimes  11.92s user 0.06s system 371% cpu 3.227 total

The parallel result takes a bit under half the time of the sequential version. 

* 1.4.3
No, it does not produce the correct result. The result in the first execution was: 663510.

* 1.4.4
In theory get() does not have to be syncronized since the method isn't used in the multithreaded execution. 
get() is only called when the final result is fetched. Since increment() is syncronized the final result after the threads have joined will be correct.
Therefore the single-threaded call to get() after joining will be correct and since it is a single-threaded call, no race conditions occur.



Exercise 1.5
------------

* 1.5.1
Sum is 1790827,000000 and should be 2000000,000000
Sum is 1864322,000000 and should be 2000000,000000
Sum is 1874701,000000 and should be 2000000,000000
Sum is 1783576,000000 and should be 2000000,000000
The Mystery class appears to be non-thread-safe.

* 1.5.2
When locking on a static method, the locking "happens on" the Class object of the instance. Therefore the ressource accessed belongs to all instances of the class.
(?) Since we're calling both static and instance methods, the final result will be less than the expected value due to lost updates. 
(?) We're simply incrementing two "different" values. 

* 1.5.3
We would not change the Mystery class, and instead consistently use either the static methods (or instance methods with compiler warning on sum()) to ensure that the same shared value is being incremented.



Exercise 1.6
------------

* 1.6.1
We would encapsulate the handling of the internal array representation so every call to add(), get() etc. would lock the internal representation in order to make sure that adding and removing elements happen atomically. 

* 1.6.2
If using the above method of ensuring thread safety, then the collection would not be very efficient with many threads calling get etc., since every operation would lock the entire collection for all threads except the one currently using/calling on the collection.

* 1.6.3
(?) No answer. This looks thread-safe to me. 



Exercise 1.7
------------

* 1.7.1
We would use an internal lock object and call syncronized on that object before incrementing the internal totalSize field. 

* 1.7.2
We would use the same approach as defined in 1.7.1.



Exercise 1.8
------------

* 1.8.1
The static syncronized call operates on the Class object instead of the actual object instance. Therefore the result is unexpected.

* 1.8.2
We would use an internal lock object, and call syncronized on that lock object before accessing the internal count member. 
